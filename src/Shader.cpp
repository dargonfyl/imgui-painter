#include "Shader.hpp"


namespace {
	/**
	 * Reads a shader's file contents.
	 * 
	 * @param path    Can be relative
	 * 
	 * @return string containing the shader contents.
	 */
	std::string read_shader(std::string &path) {
		try {
			std::ifstream filestream(path);
			std::stringstream codestream;

			codestream << filestream.rdbuf();

			filestream.close();

			return codestream.str();  // need to return value
		} catch (std::exception &e) {
			std::cerr << "ERROR::SHADER::FILE_NOT_SUCCESFULLY_READ" << std::endl;
			exit(EXIT_FAILURE);
		}
	}


	/**
	 * Reports on a potential error. Only used in Shader constructor.
	 * 
	 * @param shader         Shader ID generated by OpenGL
	 * @param extra_message  Any extra messages to report with
	 */
	void check_shader_error(GLuint shader, std::string extra_message) {
		int success;
		char err_message[512];
		glGetShaderiv(shader, GL_COMPILE_STATUS, &success);
		if (!success) {
			glGetShaderInfoLog(shader, 512, NULL, err_message);
			std::cerr << "Shader::constructor:\n" << extra_message << err_message << std::endl;
			exit(EXIT_FAILURE);
		}
	}

	/**
	 * Reports on a potential error. Only used in Shader constructor.
	 * 
	 * @param program        Shader ID generated by OpenGL
	 * @param extra_message  Any extra messages to report with
	 */
	void check_program_error(GLuint program, std::string extra_message) {
		int success;
		glGetProgramiv(program, GL_LINK_STATUS, &success);
		if (!success) {
			char err_message[512];
			glGetProgramInfoLog(program, 512, NULL, err_message);
			std::cerr << "Shader::constructor:\n" << extra_message << err_message << std::endl;
			exit(EXIT_FAILURE);
		}
	}
}


namespace Im_Painter {
	Shader::Shader() : id(0) { }

	
	Shader::Shader(std::string vertex_path, std::string fragment_path) {
		std::string vertex_code_str = read_shader(vertex_path);
		std::string fragment_code_str = read_shader(fragment_path);

		// Note: doing std::stringstream::str().c_str() causes funny problems when linking
		const char *vertex_code = vertex_code_str.c_str();
		const char *fragment_code = fragment_code_str.c_str();

		GLuint vs, fs;
		vs = glCreateShader(GL_VERTEX_SHADER);
		assert(vs != 0 && "Shader::constructor:\n glCreateShader returned 0 for vertex shader\n");
		glShaderSource(vs, 1, &vertex_code, 0);
		glCompileShader(vs);
		check_shader_error(vs, "Shader::constructor:\n");

		fs = glCreateShader(GL_FRAGMENT_SHADER);
		assert(fs != 0 && "Shader::constructor:\n glCreateShader returned 0 for fragment shader\n");
		glShaderSource(fs, 1, &fragment_code, 0);
		glCompileShader(fs);
		check_shader_error(fs, "Fragment shader:\n");


		GLuint shader_program = glCreateProgram();
		assert(shader_program != 0 && "Shader::constructor:\n glCreateProgram returned 0\n");
		glAttachShader(shader_program, vs);
		glAttachShader(shader_program, fs);
		glLinkProgram(shader_program);

		check_program_error(shader_program, "Shader program:\n");

		// Delete resources
		glDeleteShader(vs);
		glDeleteShader(fs);
		id = shader_program;
	}

	Shader::~Shader() {
		glDeleteProgram(id);
	}


	void Shader::activate() {
		assert(id != 0 && "Shader::activate: Attempted to use Shader when id == 0\n");
		glUseProgram(id);
	}


	void Shader::set_int(const std::string &name, int value) {
		glUniform1i(glGetUniformLocation(id, name.c_str()), value);
	}


	void Shader::set_float(const std::string &name, float value) {
		glUniform1f(glGetUniformLocation(id, name.c_str()), value);
	}


	void Shader::set_bool(const std::string &name, bool value) {
		glUniform1i(glGetUniformLocation(id, name.c_str()), value);  // glUniform1i works for bool
	}


	void Shader::set_mat4(const std::string &name, glm::mat4 value) {
		glUniformMatrix4fv(glGetUniformLocation(id, name.c_str()), 1, GL_FALSE, glm::value_ptr(value));
	}


	void Shader::set_vec2(const std::string &name, glm::vec2 value) {
		glUniform2fv(glGetUniformLocation(id, name.c_str()), 1, glm::value_ptr(value));
	}


	void Shader::set_vec3(const std::string &name, glm::vec3 value) {
		glUniform3fv(glGetUniformLocation(id, name.c_str()), 1, glm::value_ptr(value));
	}


	void Shader::set_vec4(const std::string &name, glm::vec4 value) {
		glUniform4fv(glGetUniformLocation(id, name.c_str()), 1, glm::value_ptr(value));
	}

} // namespace Im_Painter
